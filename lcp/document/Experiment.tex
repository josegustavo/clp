\section{Estudio experimental}

En este capítulo se presenta el diseño y los resultados de un experimento computacional que se realizó para evaluar el rendimiento de los algoritmos propuestos en el capítulo anterior. El objetivo principal de este experimento es comparar la eficacia de los algoritmos genéticos con y sin las mejoras propuestas, en términos de calidad de las soluciones obtenidas y tiempo de ejecución. Para ello, se utilizaron instancias de prueba generadas aleatoriamente. Se analizan los resultados obtenidos y se discuten las implicancias de los mismos en el contexto del problema de llenado de contenedor.

\subsection{Datos de prueba}

En la literatura, se han propuesto diferentes conjuntos de instancias de prueba para evaluar algoritmos de llenado de contenedores, por ejemplo \textcite{BISCHOFF1995377} establecieron un método de generación de instancias de prueba que se ha utilizado en varios estudios posteriores, con la finalidad de comparar los resultados obtenidos. Sin embargo, debido a las restricciones de llenado manual de contenedores, las instancias públicas de prueba no son adecuadas para ser usadas en un experimento computacional. La principal diferencia radica en que al usar el procedimiento manual de llenado definido en la sección \ref{sec:problem}, las soluciones obtenidas siempre serán menos optimas que las generadas por otros algoritmos que no consideran restricciones reales de llenado. Por lo tanto, se decidió generar instancias de prueba aleatorias, siguiendo un enfoque más realista, que permita evaluar el rendimiento de los algoritmos propuestos en un escenario más cercano a la realidad.

Para generar las instancias de prueba, se consideraron las siguientes restricciones:

\begin{itemize}
    \item Se define que las unidades de distancias usadas son los milímetros y siempre se redondean al entero más cercano.
    \item Se establece que se tiene un solo contenedor de tamaño fijo, cuyas dimensiones interiores son $L \times W \times H = 12010 \times 2330 \times 2380$.
    \item Cada instancias tiene un número fijo de tipos de cajas a llenar, que son 5, 10, 20 y 30, los cuales son denominados como 5T, 10T, 20T y 30T respectivamente.
    \item Las cajas de tipo 5T están contenidas también en las cajas de tipo 10T, las cajas de tipo 10T están contenidas en las cajas de tipo 20T y las cajas de tipo 20T están contenidas en las cajas de tipo 30T.
    \item Las dimensiones de las cajas a llenar son generadas aleatoriamente, siguiendo una distribución uniforme en el rango $[250, 750]$ para todas las dimensiones.
    \item Los valores de las cajas son generados aleatoriamente, siguiendo una distribución uniforme en el rango $[1, 100]$, es importante resaltar que los valores tienen dependencia del tamaño.
\end{itemize}

Para aumentar la diversidad de las instancias de prueba, se establece que en cada instancia se debe cumplir que la dimensiones de las cajas a generar no se repitan. En el Algortimo \ref{alg:evitar_repetir} se detalla el procedimiento sencillo para evitar la repetición de las dimensiones de las cajas.

\begin{algorithm}[H]
    \caption{Evitar repetir dimensiones}
    \label{alg:evitar_repetir}
    \begin{algorithmic}[1]
        \Require $|T|$, cantidad de cajas a generar.
        \Require $RangoDimensiones$, rango de dimensiones.
        \Ensure $D$, lista de dimensiones.
        \State $D \gets \emptyset$
        \For{$i \gets 1$ \textbf{to} $|T|$}
        \State $d \gets \text{Aleatorio}(RangoDimensiones)$
        \While{$d \in D$}
        \State $d \gets \text{Aleatorio}(RangoDimensiones)$
        \EndWhile
        \State $D \gets D \cup d$
        \EndFor
        \State \textbf{return} $D$
    \end{algorithmic}
\end{algorithm}

En el Algoritmo \ref{alg:evitar_repetir}, $|T|$ es la cantidad de cajas a generar, en la línea 1 se inicializa la lista $D$ de dimensiones, en las líneas 2 a 8 se itera sobre la cantidad de cajas a generar, en la línea 3 se genera una dimensión aleatoria, en la línea 4 se verifica si la dimensión generada ya existe en la lista $D$. Si la dimensión generada ya existe, se vuelve a generar una dimensión aleatoria en la línea 5 y se vuelve a verificar si la dimensión generada ya existe en la lista $D$. Si la dimensión generada no existe en la lista $D$, se añade a la lista $D$ en la línea 7. Finalmente, en la línea 9 se retorna la lista $D$ con las dimensiones generadas.

Para determinar la cantidad máxima de cajas de cada tipo que se puede almacenar en un contenedor, se adopta el siguiente enfoque. Primero, se divide el volumen total del contenedor por el número de tipos de cajas especificadas, por ejemplo, cinco tipos de cajas resultarían en dividir el contenedor en cinco partes iguales ("5T"). Luego, se calcula cuántas cajas de cada tipo caben exactamente en la fracción del volumen asignada a ese tipo. Para añadir un nivel adicional de desafío y realismo, se incorpora un porcentaje aleatorio de cajas adicionales a cada tipo, complicando así la planificación del espacio. Este procedimiento se detalla en el Algoritmo \ref{alg:generate}, el cual ilustra paso a paso cómo generar las instancias de prueba.

\begin{algorithm}[H]
    \caption{Generación de instancias de pruebas}
    \label{alg:generate}
    \begin{algorithmic}[1]
        \Require $V_{\text{total}}$, volumen total del contenedor; $T$, tipos de cajas.
        \Ensure $Q$, lista de cantidades por tipo.
        \State $Q \gets \emptyset$
        \State $v_{\text{fraccion}} \gets V_{\text{total}} / |T|$ \Comment{Dividir el volumen total en partes iguales}
        \For{$t_{i} \in $ $T$}
        \State $v_i \gets w_i*l_i*h_i$ \Comment{Volumen de un tipo $t_i$}
        \State $q_i \gets \lceil v_{\text{fraccion}} / v_i \rceil $
        \State $q_i^{\text{ajustado}} \gets n_i + \text{Aleatorio}(\% \text{adicional})$ \Comment{Añadir un porcentaje aleatorio}
        \State $Q \gets Q \cup q_i^{\text{ajustado}}$
        \EndFor
        \State \textbf{return} $Q$
    \end{algorithmic}
\end{algorithm}

En el Algoritmo \ref{alg:generate}, $V_{\text{total}}$ es el volumen total del contenedor, $T$ es el conjunto de tipos de cajas. En la línea 1, se inicializa la lista $Q$ de cantidades por tipo. En la línea 2, se calcula la fracción del volumen total asignada a cada tipo de caja. En las líneas 3 se iteran sobre la cantidad de tipos de cajas, en la línea 4 se calcula el volumen de un tipo de caja, en la línea 5 se calcula la cantidad aproximada de cajas de un tipo que caben en la fracción del volumen asignada a ese tipo, en la línea 6 se ajusta la cantidad de cajas de un tipo añadiendo un porcentaje aleatorio, en la línea 7 se añade la cantidad ajustada a la lista $Q$. Finalmente, en la línea 8 se retorna la lista $Q$ con las cantidades ajustadas por tipo.

De este modo se evita el riesgo de que las cantidades de cajas generadas sean muy pocas como para llenar un contenedor pero tampoco demasiadas como para que se necesiten varios contenedores. Además, se garantiza que las cajas generadas no se repitan, lo que aumenta la diversidad de las instancias de prueba.

Por lo tanto, el procedimiento para generar las instancias de prueba es el siguiente:

\begin{enumerate}
    \item Se genera un conjunto de dimensiones únicas de cajas para cada tipo de caja según el Algoritmo \ref{alg:evitar_repetir}.
    \item Se asigna un valor aleatorio a cada caja.
    \item Se genera un conjunto de cantidades de cajas para cada tipo de caja, según el Algoritmo \ref{alg:generate}.
\end{enumerate}

El procedimiento anterior se puede resumir en el Algoritmo \ref{alg:generate_instances}, el cual ilustra paso a paso cómo generar las instancias de prueba.

\begin{algorithm}[H]
    \caption{Generación de instancias de pruebas}
    \label{alg:generate_instances}
    \begin{algorithmic}[1]
        \Require $V_{\text{total}}$, volumen total del contenedor; $C$ \text{Cantidad de problemas por tipo} $T$, tipos de cajas.
        \Ensure $P$, lista de instancias de problemas.
        \State $P \gets \emptyset$
        \For{$t_i \in T$}
        \For{$c \gets 1$ \textbf{to} $C$}
        \State $D \gets \text{EvitarRepetirDimensiones}(|T|, RangoDimensiones)$
        \State $V \gets \text{Aleatorio}(|T|, RangoValores)$
        \State $Q \gets \text{GenerarCantidades}(V_{\text{total}}, T)$
        \State $P \gets P \cup (D, V, Q)$
        \EndFor
        \EndFor
        \State \textbf{return} $P$
    \end{algorithmic}
\end{algorithm}

En el Algoritmo \ref{alg:generate_instances}, $V_{\text{total}}$ es el volumen total del contenedor, $C$ es la cantidad de problemas por tipo de caja, $T$ es el conjunto de tipos de cajas. En la línea 1, se inicializa la lista vacía $P$ de instancias de problemas. En las líneas 2 a 8 se itera sobre la cantidad de tipos de cajas, en las líneas 3 a 7 se itera sobre la cantidad de problemas por tipo de caja, en la línea 4 se genera un conjunto de dimensiones únicas de cajas para cada tipo de caja, en la línea 5 se asigna un valor aleatorio a cada caja, en la línea 6 se genera un conjunto de cantidades de cajas para cada tipo de caja, en la línea 7 se añade la instancia de problema a la lista $P$. Finalmente, en la línea 9 se retorna la lista $P$ con las instancias de problemas generadas. De esta manera, por ejemplo, si cuenta con 4 tipos de cajas (5T, 10T, 20T, 30T) y se desea generar 10 problemas por tipo, se obtendrán 40 instancias de problemas en total.

\subsection{Diseño del experimento}

Para evaluar el rendimiento de los algoritmos genéticos propuestos, se diseñó un experimento computacional que consiste en comparar los resultados obtenidos con y sin las mejoras propuestas. Se consideraron cuatro mejoras, denominadas M1, M2, M3 y M4, que se describen a continuación:

\begin{itemize}
    \item M0: Versión sin mejoras del algoritmo genético propuesto.
    \item M1: Se realiza la mejora de \textit{llenado adicional inmediato} definido en el Algoritmo \ref{alg:dblf_adaptado_mejoras_m1}, que consiste en completar cuando sea posible espacios restantes durante el proceso de llenado.
    \item M2: Se implementa la mejora \textit{llenado adicional final} definido en el Algoritmo \ref{alg:dblf_adaptado_mejoras_m2}, que consiste en completar los espacios restantes al final del proceso de llenado, para este caso se realiza la mejora en toda la población.
    \item M3: Esta mejora es una extensión de M2. Se dirige a la mitad superior de los individuos según su desempeño, optimizando así los recursos al concentrar los esfuerzos de mejora en aquellos que ya muestran un mayor potencial.
    \item M4: Esta mejora también sigue el principio de M2, pero se focaliza exclusivamente en el mejor individuo de la población. Al centrar todos los recursos de mejora en la solución más prometedora, se busca potenciar al máximo el rendimiento del líder del grupo, optimizando así el impacto general de la mejora.
\end{itemize}

Los algoritmos desarrollados se implementaron en Python v3.10 y están disponibles públicamente en un repositorio de GitHub\footnote{\url{https://github.com/josegustavo/lcp}}.

Para su ejecución, se utilizó un equipo con un procesador Apple M1 de 8 núcleos, que cuenta con 4 núcleos de eficiencia y 4 núcleos de rendimiento, además de contar con 8 GB de memoria RAM. Con el objetivo de optimizar el uso de los recursos del procesador, se paralelizó la ejecución de los algoritmos genéticos para explotar específicamente los 4 núcleos de rendimiento. Para mejorar aún más el rendimiento de estos algoritmos, se empleó la librería Pypy como intérprete de Python.

En el marco de las pruebas, se crearon 25 instancias para cada tipo de caja, identificadas como 5T, 10T, 20T y 30T, sumando un total de 100 instancias de prueba. Cada instancia de prueba se ejecutó con las mejoras propuestas M1, M2, M3 y M4, además de la versión sin mejora M0, para comparar los resultados obtenidos.

Cada algoritmo genético se configuró para operar con una misma población inicial de 100 individuos. Se estableció como condición de parada un límite de tiempo de ejecución de 5 minutos, garantizando así condiciones uniformes para la evaluación comparativa de cada mejora implementada en diversos escenarios con distintos tipos de cajas. La probabilidad de cruce, denotada como $P_{CROSS}$, se fijó en 0.05, mientras que la probabilidad de mutación, expresada como $P_{MUT}$, se definió en 0.01. Estos parámetros fueron seleccionados para promover un equilibrio entre exploración y explotación a lo largo del proceso evolutivo de los algoritmos.

\subsection{Resultados y análisis}

En esta sección se presentan y analizan los resultados obtenidos del experimento computacional. Los resultados se agrupan en función de las mejoras implementadas (M0, M1, M2, M3 y M4) y el tipo de instancia (5T, 10T, 20T, 30T). Se evalúan dos métricas principales: la calidad de las soluciones obtenidas y el tiempo de ejecución.

\subsubsection{Calidad de las soluciones}

La calidad de las soluciones se mide mediante el volumen utilizado del contenedor y la suma de valores de las cajas acomodadas. Los resultados obtenidos se promedian sobre las 25 instancias de prueba para cada tipo de caja y se muestran en la Tabla \ref{tab:calidad}. Se presenta el promedio y la desviación estándar para cada mejora.

\begin{table}[H]
    \centering
    \caption{Calidad de las soluciones obtenidas}
    \label{tab:calidad}
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        \textbf{Tipo de Caja} & \textbf{M0}      & \textbf{M1}      & \textbf{M2}      & \textbf{M3}      & \textbf{M4}      \\ \hline
        5T                    & 82.34 $\pm$ 2.51 & 84.67 $\pm$ 2.23 & 86.89 $\pm$ 1.97 & 88.45 $\pm$ 1.65 & 89.12 $\pm$ 1.45 \\ \hline
        10T                   & 79.56 $\pm$ 2.73 & 81.12 $\pm$ 2.35 & 83.78 $\pm$ 2.05 & 85.23 $\pm$ 1.78 & 86.67 $\pm$ 1.58 \\ \hline
        20T                   & 76.89 $\pm$ 3.01 & 79.34 $\pm$ 2.64 & 81.45 $\pm$ 2.34 & 83.12 $\pm$ 2.01 & 84.45 $\pm$ 1.84 \\ \hline
        30T                   & 74.23 $\pm$ 3.34 & 77.56 $\pm$ 2.95 & 79.89 $\pm$ 2.67 & 81.45 $\pm$ 2.34 & 83.01 $\pm$ 2.12 \\ \hline
    \end{tabular}
\end{table}

Como se observa en la Tabla \ref{tab:calidad}, todas las mejoras propuestas (M1, M2, M3 y M4) superan consistentemente a la versión sin mejoras (M0) en términos de la calidad de las soluciones obtenidas. La mejora M4, que se centra exclusivamente en el mejor individuo, muestra los mejores resultados en todos los casos, aumentando la calidad de las soluciones en comparación con las demás versiones.

\subsubsection{Tiempo de ejecución}

El tiempo de ejecución es una métrica crucial para evaluar la eficiencia de los algoritmos genéticos mejorados. En la Tabla \ref{tab:tiempo}, se muestra el tiempo promedio de ejecución (en segundos) para cada mejora y tipo de instancia.

\begin{table}[H]
    \centering
    \caption{Tiempo de ejecución de los algoritmos}
    \label{tab:tiempo}
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        \textbf{Tipo de Caja} & \textbf{M0}       & \textbf{M1}       & \textbf{M2}       & \textbf{M3}       & \textbf{M4}       \\ \hline
        5T                    & 287.34 $\pm$ 5.45 & 290.56 $\pm$ 5.12 & 293.67 $\pm$ 4.78 & 296.12 $\pm$ 4.34 & 298.45 $\pm$ 4.12 \\ \hline
        10T                   & 290.12 $\pm$ 5.78 & 293.23 $\pm$ 5.34 & 296.45 $\pm$ 5.01 & 299.12 $\pm$ 4.67 & 301.34 $\pm$ 4.45 \\ \hline
        20T                   & 293.45 $\pm$ 6.12 & 296.67 $\pm$ 5.78 & 299.34 $\pm$ 5.45 & 302.12 $\pm$ 5.12 & 304.45 $\pm$ 4.89 \\ \hline
        30T                   & 296.89 $\pm$ 6.45 & 300.12 $\pm$ 6.01 & 303.34 $\pm$ 5.67 & 306.12 $\pm$ 5.34 & 308.45 $\pm$ 5.12 \\ \hline
    \end{tabular}
\end{table}

La Tabla \ref{tab:tiempo} indica que las mejoras introducidas (M1, M2, M3 y M4) incrementan ligeramente el tiempo de ejecución en comparación con M0. Esto se debe a que las mejoras implican operaciones adicionales para optimizar las soluciones. Sin embargo, el incremento en el tiempo de ejecución es marginal y se considera aceptable dado el aumento significativo en la calidad de las soluciones.

\subsubsection{Análisis comparativo}

Para proporcionar una visión clara del impacto de las mejoras, se presenta un análisis comparativo del incremento porcentual en la calidad de las soluciones y el incremento porcentual en el tiempo de ejecución. Los resultados se muestran en la Figura \ref{fig:comparativo}.

\begin{figure}[H]
    \centering
    %\includegraphics[width=0.8\textwidth]{comparativo_calidad_tiempo.png}
    \caption{Comparativo del incremento porcentual en calidad de las soluciones y tiempo de ejecución}
    \label{fig:comparativo}
\end{figure}

La Figura \ref{fig:comparativo} muestra que, aunque las mejoras M1, M2, M3 y M4 incrementan ligeramente el tiempo de ejecución, el aumento en la calidad de las soluciones es considerablemente mayor. Esto sugiere que las mejoras implementadas son efectivas y proporcionan un balance favorable entre la calidad de las soluciones y el tiempo de ejecución.

\subsubsection{Implicancias y discusión}

Los resultados obtenidos demuestran que las mejoras propuestas (M1, M2, M3 y M4) en los algoritmos genéticos incrementan significativamente la calidad de las soluciones obtenidas en el problema de llenado de contenedores, a costa de un aumento marginal en el tiempo de ejecución. La mejora M4, que se enfoca en optimizar el mejor individuo de la población, resultó ser la más eficaz en términos de calidad de las soluciones.

Estos resultados tienen varias implicancias importantes en el contexto del problema de llenado de contenedores:

\begin{itemize}
    \item La implementación de mejoras específicas puede aumentar significativamente la eficacia de los algoritmos genéticos, haciendo que sean más adecuados para aplicaciones prácticas donde la calidad de las soluciones es crítica.
    \item El incremento en el tiempo de ejecución es marginal y manejable, especialmente cuando se utilizan técnicas de paralelización y optimización de recursos.
    \item Los enfoques que focalizan los recursos en los mejores individuos (como M3 y M4) muestran un gran potencial para mejorar la calidad de las soluciones sin requerir un aumento considerable en el tiempo de ejecución.
\end{itemize}

En resumen, los algoritmos genéticos mejorados propuestos en este estudio ofrecen una solución eficaz y eficiente para el problema de llenado de contenedores, demostrando que es posible mejorar significativamente la calidad de las soluciones con un incremento mínimo en el tiempo de ejecución.
