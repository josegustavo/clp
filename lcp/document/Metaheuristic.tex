\section{Metaheurística}

\subsection{Codificación de soluciones}
    
Existen diferentes maneras de codificar las soluciones para el problema de llenado de contenedores. Algunos de los más interesantes son por ejemplo Bortfeldt y otros \cite{baez/article} que propusieron una codificación basada dobles o simplemente dos listas de igual longitud, la primera representa la secuencia de llenado de los paquetes y la segunda indica la rotación de cada paquete. De manera similar Xianbo y otros [2] propusieron el uso de la primera lista como la secuencia de llenado de cada tipo de paquete y la segunda como la rotación de cada tipo de paquete.

Sin embargo, para las restricciones en nuestro problema, esta codificaciones no son adecuadas ya que necesitamos considerar que las cantidades de un tipo de paquete no son fijas sino que pueden variar de un rango mínimo a un máximo. Por lo tanto, proponemos una codificación basada en 3 listas de igual longitud, la primera lista representa la secuencia de llenado de cada tipo de paquete, la segunda lista indica la rotación de cada tipo de paquete y la tercera lista indica la cantidad de paquetes de cada tipo que se llenan en el contenedor.


Por ejemplo, si tenemos 4 tipos de paquetes $T=\{1,2,3,4\}$, todos los tipos con un mínimo de 0 paquetes y el tipo 1 con un máximo de 10 paquetes $q_1 \in [0,10]$, el tipo 2 con un máximo de 30 paquetes $q_1 \in [0,30]$, el tipo 3 con un máximo de 20 paquetes $q_1 \in [0,20]$ y el tipo 4 con un máximo de 22 paquetes $q_4 \in [0,22]$, una solución factible para el problema de llenado de contenedores podría ser la siguiente:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{Figures/codificación.png}
    \caption{Codificación de una solución con 4 tipos de cajas}
    \label{fig:codificación}
\end{figure}

La primera lista indica que el tipo 2 se llena primero, luego el tipo 1 seguido del tipo 4, y finalmente el tipo 3. La segunda lista indica que el tipo 2 no se rota, el tipo 1 se rota, el tipo 4 se rota y el tipo 3 no se rota. La tercera lista indica que se llenan 27 paquetes del tipo 2, 10 paquetes del tipo 1, 18 paquetes del tipo 4 y 13 paquetes del tipo 3. En la Figura 2 se muestran dos ejemplos adicionales sobre cómo se usa la codificación propuesta para representar soluciones para el problema.

Estas tres listas son necesarias para el algoritmo de llenado presentado en la sección 2, el cuál se encargará de llenar el contenedor de forma determinista y de acuerdo a las restricciones del problema, es decir dada una lista siempre se llenará el contenedor de una única manera. Una vez que el contenedor se ha llenado y si aún quedan paquetes por llenar se irán descartando los paquetes que ya no caben lo que implica actualizar o corregir la lista de cantidades de paquetes de cada tipo, de este modo se garantiza que la solución sea factible.

Otra ventaja de esta codificación es la flexibilidad que ofrece para adaptar el problema a diferentes restricciones, por ejemplo si se desea considerar una cantidad fija de paquetes de un tipo, simplemente se puede fijar el mínimo y el máximo de ese tipo de paquete. De igual manera, la estructura soporta si se desea considerar otros tipos de rotaciones, además de las consideradas en el presente trabajo. 

Este tipo de codificación permite representar soluciones factibles para el problema de llenado de contenedores, ya que considera la cantidad de paquetes de cada tipo que se llenan en el contenedor. Además, esta codificación es fácil de implementar y de entender, lo que facilita la implementación del algoritmo de llenado y del algoritmo de optimización para resolver el problema.


    
\subsection{Población inicial}

Para generar la población inicial se propone un mecanismo simple de generación de soluciones aleatorias. Dado un conjunto de tipos de paquetes $T = \{1,2, \ldots, n\}$, donde cada tipo de paquete $t_i \in T$ tiene un mínimo y un máximo de paquetes a insertar en el contenedor $t_i \in [t_i^{min},t_i^{max}]$, se generan soluciones aleatorias de la siguiente manera:

\begin{enumerate}
\item Se selecciona aleatoriamente un tipo de paquete $t_i \in T$.
\item Se selecciona aleatoriamente un tipo de rotación $r_i \in R, R \in \{0,1\}$.
\item Se selecciona aleatoriamente una cantidad de paquetes $q_i \in [t_i^{min},t_i^{max}]$.
\item Se repiten los pasos 1 al 3 hasta que se hayan seleccionado todos los tipos de paquetes.
\item Se repiten los pasos 1 al 4 hasta que se hayan generado $N$ soluciones.
\end{enumerate}

El algoritmo de generación de la población inicial se muestra en el Algoritmo~\ref{alg:generacionPoblacionInicial}. En este algoritmo, $T$ es el conjunto de tipos de paquetes, $R$ es el conjunto de rotaciones, $N$ es el tamaño de la población, $t_i^{min}$ y $t_i^{max}$ son el mínimo y el máximo de paquetes de cada tipo, respectivamente, y $P$ es la población inicial.

\begin{algorithm}[H]
\caption{Generación de la población inicial}\label{alg:generacionPoblacionInicial}
\begin{algorithmic}[1]
\Require $T, R, N, t_i^{\min}, t_i^{\max}$
\Ensure $P$
\State $P \leftarrow \emptyset$
\For{$i = 1$ to $N$}
    \State $S \leftarrow \emptyset$
    \For{each $t_i \in T$}
        \State $r_i \leftarrow$ rotación aleatoria de $t_i$
        \State $q_i \leftarrow$ cantidad aleatoria de paquetes de $t_i$
        \State $S \leftarrow S \cup \{(t_i, r_i, q_i)\}$
    \EndFor
    \State $P \leftarrow P \cup \{S\}$
\EndFor
\State \Return $P$
\end{algorithmic}
\end{algorithm}

De esta manera, se generan soluciones aleatorias que cumplen con las restricciones del problema, es decir, se garantiza que la cantidad de paquetes de cada tipo que se insertan en el contenedor esté dentro del rango definido por el mínimo y el máximo de paquetes de cada tipo. Además, se garantiza que la cantidad de paquetes de cada tipo que se insertan en el contenedor sea un número entero.

\subsection{Selección}

Para seleccionar las soluciones que se utilizarán en cada generación del algoritmo evolutivo, se propone un mecanismo de selección basado en el método de torneo usando un tamaño de torneo de 2, también conocido como torneo binario. Anand y otros [3] lo describen como uno de los más eficientes métodos de selección para algoritmos evolutivos. Para usar el método de torneo binario, se seleccionan aleatoriamente dos soluciones de la población y se selecciona la mejor solución de las dos. Este proceso se lleva a cabo junto con el operador de cruce para lo cual cada padre se selecciona mediante un torneo binario.

En el Algoritmo~\ref{alg:seleccionPadres}, $P$ es la población, $N$ es el tamaño de la población, $P1$ y $P2$ son los padres seleccionados.

\begin{algorithm}[H]
\caption{Selección de padres}\label{alg:seleccionPadres}
\begin{algorithmic}[1]
\Require $P, N$
\Ensure $P1, P2$

\State $P1 \leftarrow$ solución aleatoria de $P$
\State $P2 \leftarrow$ solución aleatoria de $P$
\For{$i = 1$ to $N$}
    \State $S1 \leftarrow$ solución aleatoria de $P$
    \State $S2 \leftarrow$ solución aleatoria de $P$ - $S1$
    \If{$S1$ > $P1$}
        \State $P1 \leftarrow S1$
    \EndIf
    \State $S3 \leftarrow$ solución aleatoria de $P$
    \State $S4 \leftarrow$ solución aleatoria de $P$ - $S3$
    \If{$S3$ > $P2$}
        \State $P2 \leftarrow S3$
    \EndIf
\EndFor
\State \Return $P1, P2$
\end{algorithmic}
\end{algorithm}

De esta manera, se generan dos listas de padres que se utilizarán en el operador de cruce para generar una nueva población. Este método de selección procura que siempre se tienda a seleccionar soluciones mejores aunque tampoco se descartan soluciones peores, lo que permite mantener la diversidad en la población.

\subsection{Cruce}

Como resultado de la selección de padres, se generan dos listas de padres que se utilizarán en el operador de cruce para generar una nueva población. Para el operador de cruce se propone un mecanismo de cruce basado en el cruce de un punto. Según Umbarkar y otros [4], para este tipo de operador, se selecciona un punto aleatorio en la solución y se intercambian las partes de las dos soluciones que están a la izquierda y a la derecha del punto. Este operador de cruce es simple y fácil de implementar, y se ha demostrado que es eficiente para resolver problemas de optimización combinatoria.

Cabe mencionar que el operador de cruce se aplica a una proporción de la población, dependiendo de la tasa de cruce $P_CROSS$, que se define como la probabilidad de que dos soluciones seleccionadas se crucen. De esta manera, se garantiza que la población se mantenga diversa y que se generen nuevas soluciones que puedan ser mejores que las soluciones actuales.

En el Algoritmo~\ref{alg:crucePadresGenerico}, $P1$ y $P2$ son los padres seleccionados, $C1$ y $C2$ son los hijos generados, $N$ es el tamaño de la población y $T$ es el conjunto de tipos de paquetes.

\begin{algorithm}[H]
\caption{Cruce de padres genérico}\label{alg:crucePadresGenerico}
\begin{algorithmic}[1]
\Require $P1, P2, N, T$
\Ensure $C1, C2$

\State $C1 \leftarrow \emptyset$
\State $C2 \leftarrow \emptyset$
\State $p \leftarrow$ punto aleatorio en la solución
\For{$i = 1$ to $N$}
    \If{$i \leq p$}
        \State $C1 \leftarrow C1 \cup P1[i]$
        \State $C2 \leftarrow C2 \cup P2[i]$
    \Else
        \State $C1 \leftarrow C1 \cup P2[i]$
        \State $C2 \leftarrow C2 \cup P1[i]$
    \EndIf
\EndFor
\State \Return $C1, C2$
\end{algorithmic}
\end{algorithm}

Aunque este algoritmo de cruce es genérico y aplicado a muchos tipos de problemas, se puede adaptar para el problema de llenado de contenedores y para considerar la codificación propuesta en la sección 5.1. ya que realizar el cruzamiento simple podría generar soluciones que no sean factibles, por ejemplo repitiendo un tipo de paquete que ya se ha llenado en el contenedor. Por lo tanto, se propone un mecanismo de cruce que garantice que las soluciones generadas sean factibles. Para ello, se propone usar la primera partición de la solución de un padre y completar la solución con tipos de paquetes que no se han seleccionado en la primera partición. De esta manera, se garantiza que la solución generada sea factible y que contenga todos los tipos de paquetes.

Entonces, el algoritmo de cruce se modifica de la siguiente manera:

\begin{algorithm}[H]
\caption{Cruce de padres propuesto}\label{alg:crucePadresPropuesto}
\begin{algorithmic}[1]
\Require $P1, P2, N, T$
\Ensure $C1, C2$

\State $C1 \leftarrow \emptyset$
\State $C2 \leftarrow \emptyset$
\State $p \leftarrow$ punto aleatorio en la solución
\For{$i = 1$ to $N$}
    \If{$i \leq p$}
        \State $C1 \leftarrow C1 \cup P1[i]$
        \State $C2 \leftarrow C2 \cup P2[i]$
    \Else
        \For{each $t_i \in T$}
            \If{$C1$ no contiene $P2[i]$}
                \State $C1 \leftarrow C1 \cup P2[i]$
            \EndIf
            \If{$C2$ no contiene $P1[i]$}
                \State $C2 \leftarrow C2 \cup P1[i]$
            \EndIf
        \EndFor
    \EndIf
\EndFor
\State \Return $C1, C2$
\end{algorithmic}
\end{algorithm}


De esta manera, se garantiza que las soluciones generadas sean factibles y que contengan todos los tipos de paquetes. Además, se garantiza que las soluciones generadas sean diferentes a las soluciones de los padres, lo que permite mantener la diversidad en la población.

\subsection{Mutación}

Según Dockhorn y otros \textcite{Dockhorn2022}, la mutación consiste en aplicar pequeños cambios a las soluciones candidatas para tratar de explorar nuevas regiones locales del espacio de búsqueda. Para el presente problema, ya que codificación propuesta consta de tres listas, se propone también tres operadores de mutación, uno para cada lista. El primer tipo de mutación intercambia dos tipos de paquetes en la secuencia de llenado, el segundo tipo de mutación cambia la rotación de un tipo de paquete y el tercer tipo de mutación cambia la cantidad de paquetes de un tipo de paquete.

El algoritmo de mutación se muestra en el Algoritmo~\ref{alg:mutacion}. En este algoritmo, $S$ es la solución a mutar, $T$ es el conjunto de tipos de paquetes, $R$ es el conjunto de rotaciones, $t_i^{\min}$ y $t_i^{\max}$ son el mínimo y el máximo de paquetes de cada tipo, respectivamente, y $S'$ es la solución mutada.

\begin{algorithm}[H]
\caption{Mutación de soluciones}\label{alg:mutacion}
\begin{algorithmic}[1]
\Require $S, T, R, t_i^{\min}, t_i^{\max}$
\Ensure $S'$
\State $S' \leftarrow S$
\State $r \leftarrow$ número aleatorio entre 1 y 3
\If{$r = 1$}
    \State $i, j \leftarrow$ dos números aleatorios entre 1 y $|T|$
    \State $S'[i], S'[j] \leftarrow S'[j], S'[i]$
\ElsIf{$r = 2$}
    \State $i \leftarrow$ número aleatorio entre 1 y $|T|$
    \State $S'[i] \leftarrow$ rotación aleatoria de $T[i]$
\ElsIf{$r = 3$}
    \State $i \leftarrow$ número aleatorio entre 1 y $|T|$
    \State $q \leftarrow$ cantidad aleatoria de paquetes de $T[i]$
    \State $S'[i] \leftarrow q$
\EndIf
\State \Return $S'$
\end{algorithmic}
\end{algorithm}

\subsection{Elitismo}

Según Hasni y otros \textcite{Hasni2013}, el principio del elitismo consiste en mantener las mejores soluciones de una generación a la siguiente, lo que permite garantizar que siempre se mantenga la mejor solución encontrada hasta el momento, ya que los operadores de cruce y mutación pueden generar soluciones las cuales no sean mejores que las soluciones actuales, en dicho caso se reemplazan el mejor individuo de la generación anterior por el peor individuo de la generación actual.