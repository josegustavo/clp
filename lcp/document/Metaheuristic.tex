\section{Metaheurística}

\subsection{Codificación de soluciones}
\label{sec:codificacion}

Existen diferentes maneras de codificar las soluciones para el problema de llenado de contenedores. Algunos de los más interesantes son por ejemplo Bortfeldt y otros \cite{GEHRING1997401} que propusieron una codificación basada dobles o simplemente dos listas de igual longitud, la primera representa la secuencia de llenado de los paquetes y la segunda indica la rotación de cada paquete. De manera similar Xianbo y otros [2] propusieron el uso de la primera lista como la secuencia de llenado de cada tipo de paquete y la segunda como la rotación de cada tipo de paquete.

Sin embargo, para las restricciones en nuestro problema, esta codificaciones no son adecuadas ya que necesitamos considerar que las cantidades de un tipo de paquete no son fijas sino que pueden variar de un rango mínimo a un máximo. Por lo tanto, proponemos una codificación basada en 3 listas de igual longitud, la primera lista representa la secuencia de llenado de cada tipo de paquete, la segunda lista indica la rotación de cada tipo de paquete y la tercera lista indica la cantidad de paquetes de cada tipo que se llenan en el contenedor.


Por ejemplo, si tenemos 4 tipos de paquetes $T=\{1,2,3,4\}$, todos los tipos con un mínimo de 0 paquetes y el tipo 1 con un máximo de 10 paquetes $q_1 \in [0,10]$, el tipo 2 con un máximo de 30 paquetes $q_1 \in [0,30]$, el tipo 3 con un máximo de 20 paquetes $q_1 \in [0,20]$ y el tipo 4 con un máximo de 22 paquetes $q_4 \in [0,22]$, una solución factible para el problema de llenado de contenedores podría ser la siguiente:

\begin{figure}[H]
    \centering
    \includesvg[width=0.4\linewidth]{Figures/codificacion.svg}
    \caption{Codificación de una solución con 4 tipos de cajas}
    \label{fig:codificación}
\end{figure}

La primera lista indica que el tipo 2 se llena primero, luego el tipo 1 seguido del tipo 4, y finalmente el tipo 3. La segunda lista indica que el tipo 2 no se rota, el tipo 1 se rota, el tipo 4 se rota y el tipo 3 no se rota. La tercera lista indica que se llenan 27 paquetes del tipo 2, 10 paquetes del tipo 1, 18 paquetes del tipo 4 y 13 paquetes del tipo 3. En la Figura 2 se muestran dos ejemplos adicionales sobre cómo se usa la codificación propuesta para representar soluciones para el problema.

Las tres listas mencionadas son fundamentales para el algoritmo de llenado descrito en la sección 2. Este algoritmo llena el contenedor de manera determinista, siguiendo estrictamente las restricciones establecidas por el problema. Específicamente, una lista determinada siempre resulta en un único método de llenado del contenedor. Si, después de llenar el contenedor, quedan paquetes sobrantes, se procederá a descartar aquellos que no caben, lo que requiere una actualización o corrección de la lista de cantidades de cada tipo de paquete. Este proceso asegura la factibilidad de la solución.

Otra ventaja de esta codificación es la flexibilidad que ofrece para adaptar el problema a diferentes restricciones, por ejemplo si se desea considerar una cantidad fija de paquetes de un tipo, simplemente se puede fijar el mínimo y el máximo de ese tipo de paquete. De igual manera, la estructura soporta si se desea considerar otros tipos de rotaciones, además de las consideradas en el presente trabajo.

Este tipo de codificación permite representar soluciones factibles para el problema de llenado de contenedores, ya que considera la cantidad de paquetes de cada tipo que se llenan en el contenedor. Además, esta codificación es fácil de implementar y de entender, lo que facilita la implementación del algoritmo de llenado y del algoritmo de optimización para resolver el problema.

\subsection{Función de evaluación}

La función de evaluación es una parte fundamental de cualquier algoritmo de optimización, ya que permite evaluar la calidad de las soluciones generadas por el algoritmo. Para el problema de llenado de contenedores, la función de evaluación se puede definir como la suma de los valores de los paquetes que se llenan en el contenedor, es decir, se busca maximizar el valor total de la carga que se llena en el contenedor.

Un paso previo importante antes de calcular el valor total de la carga es verificar si la solución generada es factible, es decir, si al agregar todas las cajas en los ordenes y las posiciones indicadas en la solución, se cumple que todas son colocadas en el contenedor sin superar su capacidad. Para ello, se propone un algoritmo que simula el procedimiento de llenado manual, el cual verifica si una solución generada es factible y si no lo es, lo corrige para que sea factible.

\subsubsection{Algoritmo de llenado manual}

El algoritmo de llenado propuesto está basado en el método Deepest Bottom Left with Fill (DBLF) propuesto por Karabulut y otros \cite{karabulut2004hybrid}, cuyo uso se ha extendido y varios autores han realizado propuestas para mejorarlo o adaptarlo a determinados contextos por ejemplo Wang y otros \cite{wang2010hybrid}, Kang y otros. \cite{kang2012hybrid}. El algoritmo propuesto en el presente trabajo está enfocado en cumplir las restricciones y adaptarse al contexto de un llenado manual de paquetes en un contenedor.

La idea básica del algoritmo DBLF es que los paquetes comienzan a ser llenados en el contenedor de forma secuencial, se prioriza que el paquete se coloque en las siguientes posiciones:

\begin{itemize}
    \item La posición más profunda del contenedor, que ayuda a llenar primero los espacios más alejados de la puerta y evitar obstaculizar el ingreso del operador humano al contenedor.
    \item La posición más baja del contenedor, se da naturalmente debido al efecto de la gravedad, un paquete no podría ser colocado en una posición alta si no se ha llenado primero las posiciones más bajas.
    \item La posición más a la izquierda del contenedor, aunque no es una restricción fuerte, podría usarse el criterio de priorizar la posición más a la derecha si se considera necesario, lo crucial es mantener la consistencia al elegir una de estas dos direcciones. Para el caso de este trabajo se ha elegido la posición más a la izquierda.
\end{itemize}

Al inicio del procedimiento un paquete se coloca en la posición más profunda, más baja y más a la izquierda del contenedor vacío, luego al colocar el paquete en el contenedor, el espacio restante se divide en tres nuevos subespacios, la parte superior, la parte lateral y la parte frontal, en la figura \ref{fig:subespacios} se muestra de cómo se divide el espacio restante en el contenedor al colocar un paquete.

\begin{figure}[H]
    \centering
    \includesvg[width=0.9\textwidth]{Figures/subespacios.svg}
    \caption{División del espacio restante en el contenedor al colocar un paquete. a) Subespacio frontal, b) Subespacio lateral, c) Subespacio superior.}
    \label{fig:subespacios}
\end{figure}

Cada subespacio es considerado como un nuevo contenedor y se repite el proceso de colocar el siguiente paquete en uno de los subespacios creados. Para elegir el siguiente subespacio donde colocar el siguiente paquete, se usa el mismo criterio de priorización DBL, es decir, se elige el subespacio más profundo, más bajo y más a la izquierda, luego se coloca el paquete en dicho subespacio y se repite el proceso.

En la figura \ref{fig:segundo_paquete} se muestra un ejemplo de cómo se coloca un segundo paquete en el contenedor siguiendo el algoritmo DBLF.

\begin{figure}[H]
    \centering
    \includesvg[width=0.5\textwidth]{Figures/segundo_paquete.svg}
    \caption{Ejemplo de colocación de un segundo paquete en el contenedor luego de elegir el último subespacio lateral.}
    \label{fig:segundo_paquete}
\end{figure}

Para este segundo paquete, se ha elegido el anterior subespacio lateral, el cual fué el subespacio más profundo, más bajo y más a la izquierda, siguiendo el criterio de priorización DBL, luego se coloca el paquete en dicho subespacio y se repite el proceso de dividir el espacio restante. Como resultado de esta subdivisión, se obtienen en este caso solamente dos subespacios, la parte superior y la parte lateral, ya que no queda espacio frontal para dividir. En la figura \ref{fig:segundos_subespacios} se muestra estos dos nuevos subespacios.

\begin{figure}[H]
    \centering
    \includesvg[width=0.75\textwidth]{Figures/segundos_subespacios.svg}
    \caption{División del espacio restante en el contenedor al colocar un segundo paquete. a) Nuevo subespacio lateral, b) Nuevo subespacio superior.}
    \label{fig:segundos_subespacios}
\end{figure}

Este procedimiento se repite hasta que se hayan colocado todos los paquetes en el contenedor o no se pueda colocar más paquetes debido a restricciones de espacio. En la figura \ref{fig:contruccion_muro} se muestra como este procedimiento se asemeja a un tipo de construcción de un muro el cuál es otro método de llenado de contenedores.

\begin{figure}[H]
    \centering
    \includesvg[width=0.5\textwidth]{Figures/contruccion_muro.svg}
    \caption{Ejemplo de colocación de más paquetes en el contenedor}
    \label{fig:contruccion_muro}
\end{figure}

El Algoritmo \ref{alg:dblf} muestra el procedimiento de llenado manual de paquetes en un contenedor basado en el algoritmo DBLF.

\begin{algorithm}[H]
    \caption{Algoritmo de llenado manual de paquetes en un contenedor}
    \label{alg:dblf}
    \begin{algorithmic}[1]
        \State $Paquetes \gets \text{lista de paquetes ordenados por tamaño}$
        \State \textbf{Inicialización:} $dblf \gets \text{lista inicializada con el espacio total del contenedor}$
        \State $Contenedor \gets \text{lista vacía para almacenar los paquetes colocados}$
        \For{$paquete \in Paquetes$}
        \State $SubespacioOptimo \gets \text{buscar el subespacio más adecuado en } dblf$
        \If{$SubespacioOptimo \neq \text{null}$}
        \State $Contenedor.\text{add}( \text{colocar}(paquete, SubespacioOptimo) )$
        \State $NuevosSubespacios \gets \text{dividir}(SubespacioOptimo, paquete)$
        \State $dblf.\text{remove}(SubespacioOptimo)$
        \State $dblf.\text{extend}(NuevosSubespacios)$
        \Else
        \State \textbf{print} $\text{"No se encontró espacio para el paquete."}$
        \EndIf
        \EndFor
        \State \Return $Contenedor$
    \end{algorithmic}
\end{algorithm}

El el Algoritmo \ref{alg:dblf}, en la línea 1: se inicializa una lista llamada $Paquetes$ que contiene los paquetes ordenados. Este orden será determinado previamente por el algoritmo de optimización genético, el cual se detallará en la próxima sección. En la línea 2: Se inicializa una lista llamada $dblf$, que representa los subespacios libres en el $Contenedor$. Inicialmente, esta lista contiene un único subespacio que es el contenedor entero. En la línea 3: Se crea una lista vacía llamada $Contenedor$ donde se almacenarán la posición y tamaños de los paquetes que se vayan colocando. Para la parte del proceso de llenado, en la líneas 4: El ciclo for recorre cada paquete en la lista de paquetes.
En la línea 5: Se busca en $dblf$ el primer subespacio disponible que sea suficientemente grande para el paquete. La búsqueda tiene en cuenta que el subespacio debe ser el más profundo, más bajo y más a la izquierda posible donde el paquete pueda caber. En la línea 6: Si tiene una condicional por si se encuentra o no un subespacio adecuado. De continuar con el procedimiento En la línea 7: La función $colocar$ ubica el $paquete$ en la posición más profunda, más baja y más a la izquierda del $SubespacioOptimo$ y devuelve la posición del paquete en el $Contenedor$, la función $add$ agrega el valor devuelto a la lista $Contenedor$. En la línea 8: El subespacio original $SubespacioOptimo$ donde se colocó el paquete se divide hasta en tres nuevos subespacios menores usando la función $dividir$. En la línea 9: se elimina el subespacio original $SubespacioOptimo$ de $dblf$ y en la línea 10: se agregan los nuevos subespacios a la lista $dblf$. En la línea 12: Si no se encuentra un subespacio adecuado para el paquete, se imprime un mensaje de error. Finalmente, en la línea 15: se retorna la lista $Contenedor$ con los paquetes colocados.

En el contexto del llenado manual de contenedores, la propuesta de algoritmo presentado no es suficiente ya que no considera las restricciones propias de un llenado manual, por ejemplo un paquete más grande podría ser colocado encima de varios paquetes más pequeños. Por lo tanto se proponen adaptaciones al algoritmo DBLF para adaptarlo a las restricciones de un llenado manual de contenedores.

\subsubsection{Unión de subespacios}

El primer cambio a considerar es la posibilidad que un paquete pueda ser colocado encima de otros paquetes, en el algoritmo DBLF presentado, un paquete no podía ser colocado encima de otro paquete debido a que los subespacios superiores están separados, por lo tanto se propone una estrategia de unión de subespacios similares. Por ejemplo en la figura \ref{fig:union_subespacios} se muestra como se unen dos subespacios superiores para permitir que un paquete de otro tipo pueda ser colocado encima de otros paquetes.

\begin{figure}[H]
    \centering
    \includesvg[width=0.5\textwidth]{Figures/union_subespacios.svg}
    \caption{Ejemplo de unión de dos subespacios superiores para permitir que un paquete pueda ser colocado encima de otros paquetes.}
    \label{fig:union_subespacios}
\end{figure}

Para realizar la unión de subespacios superiores, se propone un algoritmo de unión de subespacios que se detalla en el Algoritmo \ref{alg:union_subespacios}. Este algoritmo recibe como entrada la lista de subespacios disponibles y recorre dicha lista de atrás hacia adelante, buscando subespacios contiguos y similares para unirlos en un solo subespacio. El algoritmo se detiene cuando no se encuentran más subespacios para unir.

\begin{algorithm}[H]
    \caption{Algoritmo de unión de subespacios}
    \label{alg:union_subespacios}
    \begin{algorithmic}[1]
        \State $Subespacios \gets \text{lista de subespacios disponibles}$
        \State $i \gets \text{longitud de } Subespacios - 1$
        \While{$i > 0$}
        \If{$Subespacios[i].\text{esSimilar}(Subespacios[i-1])$}
        \State $Subespacios[i-1].\text{unir}(Subespacios[i])$
        \State $Subespacios.\text{remove}(Subespacios[i])$
        \EndIf
        \State $i \gets i - 1$
        \EndWhile
        \State \Return $Subespacios$
    \end{algorithmic}
\end{algorithm}

En el Algoritmo \ref{alg:union_subespacios}, en la línea 1: se inicializa una lista llamada $Subespacios$ que contiene los subespacios disponibles en el contenedor. En la línea 2: se inicializa una variable $i$ con la longitud de la lista de subespacios menos uno, esto para iterar siempre el último con el anterior. En la línea 3: Se inicia un ciclo while que recorre la lista de subespacios desde el último hasta el primero. En la línea 4: Se verifica si el subespacio actual y el subespacio anterior son similares, es decir si comparten ciertas características de posición en el contenedor y tamaño. En la línea 5: Si los subespacios son similares, se unen en un solo subespacio y se elimina el subespacio actual de la lista. En la línea 6: Se decrementa el valor de $i$ en uno. En la línea 8: Se retorna la lista de subespacios actualizada.

\subsubsection{Eliminación de subespacios inaccesibles}

En el contexto del llenado manual un espacio se vuelve inaccesible cuando un operador no puede colocar un paquete en dicho espacio debido a que fue bloqueado por otro paquete, en la figura \ref{fig:subespacio_inaccesible} se muestra un ejemplo de un subespacio inaccesible.

\begin{figure}[H]
    \centering
    \includesvg[width=0.5\textwidth]{Figures/subespacio_inaccesible.svg}
    \caption{Ejemplo de un subespacio inaccesible.}
    \label{fig:subespacio_inaccesible}
\end{figure}

La figura \ref{fig:subespacio_inaccesible} muestra desde una perspectiva superior del contenedor, en a) espacios libres en rojo que ha sido bloqueado por un paquete verde colocado, en b) este espacio inaccesible no podrá ser utilizado en su totalidad y se partirá para que quede solo la parte accesible.

Para evitar que un subespacio inaccesible sea considerado en el proceso de llenado, se propone un algoritmo de eliminación de subespacios inaccesibles que se detalla en el Algoritmo \ref{alg:eliminacion_subespacios}. Este algoritmo recibe como entrada la lista de subespacios disponibles y recorre dicha lista desde el último hacia el primero, eliminando o recortando los subespacios inaccesibles.

\begin{algorithm}[H]
    \caption{Algoritmo de eliminación de subespacios inaccesibles}
    \label{alg:eliminacion_subespacios}
    \begin{algorithmic}[1]
        \State $Subespacios \gets \text{lista de subespacios disponibles}$
        \State $i \gets \text{longitud de } Subespacios - 1$
        \While{$i > 0$}
        \If{$Subespacios[i].\text{esInaccesibleParcialmente}()$}
        \State $Subespacios[i].\text{recortar}()$
        \ElsIf{$Subespacios[i].\text{esInaccesibleTotalmente}()$}
        \State $Subespacios.\text{remove}(Subespacios[i])$
        \EndIf
        \State $i \gets i - 1$
        \EndWhile
        \State \Return $Subespacios$
    \end{algorithmic}
\end{algorithm}

En el Algoritmo \ref{alg:eliminacion_subespacios}, en la línea 1: se inicializa una lista llamada $Subespacios$ que contiene los subespacios disponibles en el contenedor. En la línea 2: se inicializa una variable $i$ con la longitud de la lista de subespacios menos uno, esto para iterar siempre desde el último ya que la lista podría ser modificada durante la ejecución del bucle. En la línea 3: Se inicia un ciclo while que recorre la lista de subespacios desde el último hasta el primero. En la línea 4: Se verifica si el subespacio actual es inaccesible parcialmente, es decir si un paquete bloquea parcialmente el subespacio. En la línea 5: Si el subespacio es inaccesible parcialmente, se recorta el subespacio para eliminar la parte inaccesible. En la línea 6: Se verifica si el subespacio actual es inaccesible totalmente, es decir si un paquete bloquea completamente el subespacio. En la línea 7: Si el subespacio es inaccesible totalmente, se elimina el subespacio de la lista. En la línea 8: Se decrementa el valor de $i$ en uno. En la línea 10: Se retorna la lista de subespacios actualizada.

\subsubsection{Eliminación de subespacios profundos}

Un espacio profundo se considera inaccesible cuando un operador no puede alcanzar dicho espacio usando sus brazos, en este caso la distancia máxima que una persona puede alcanzar con sus brazos es una constante a definir en el sistema ya que podría usarse un valor promedio que no resulte en un esfuerzo excesivo para el operador humano. Una estrategia para evitar que un espacio profundo sea considerado en el proceso de llenado es recortar la parte posterior del espacio, en la figura \ref{fig:subespacio_profundo} se muestra un ejemplo de un subespacio profundo.

\begin{figure}[H]
    \centering
    \includesvg[width=0.85\textwidth]{Figures/subespacio_profundo.svg}
    \caption{Ejemplo de un subespacio profundo.}
    \label{fig:subespacio_profundo}
\end{figure}

La figura \ref{fig:subespacio_profundo} muestra desde una perspectiva lateral del contenedor, en a) un espacio profundo en rojo, en b) este espacio profundo ha sido recortado para solo ser considerado la parte frontal accesible.

Para evitar que un subespacio profundo sea considerado en el proceso de llenado, se propone un algoritmo que se detalla en el Algoritmo \ref{alg:eliminacion_subespacios_profundos}. Este algoritmo recibe como entrada la posición de la caja más cercana a la puerta del contenedor para calcular la posición máxima que un operador puede alcanzar con sus manos, y también recibe la lista de subespacios disponibles, recorre dicha lista desde el último hacia el primero, eliminando o recortando los subespacios profundos.

\begin{algorithm}[H]
    \caption{Algoritmo de eliminación de subespacios profundos}
    \label{alg:eliminacion_subespacios_profundos}
    \begin{algorithmic}[1]
        \State $Subespacios \gets \text{lista de subespacios disponibles}$
        \State $PosicionCajaMasCercana \gets \text{posición de la caja más cercana a la puerta}$
        \State $PosicionMaxima \gets \text{posición máxima que un operador puede alcanzar}$
        \State $i \gets \text{longitud de } Subespacios - 1$
        \While{$i > 0$}
        \If{$Subespacios[i].\text{esProfundoParcialmente}(PosicionMaxima)$}
        \State $Subespacios[i].\text{recortar}()$
        \ElsIf{$Subespacios[i].\text{esProfundoTotalmente}(PosicionMaxima)$}
        \State $Subespacios.\text{remove}(Subespacios[i])$
        \EndIf
        \State $i \gets i - 1$
        \EndWhile
        \State \Return $Subespacios$
    \end{algorithmic}
\end{algorithm}

En el Algoritmo \ref{alg:eliminacion_subespacios_profundos}, en la línea 1: se inicializa una lista llamada $Subespacios$ que contiene los subespacios disponibles en el contenedor. En la línea 2: se inicializa una variable $PosicionCajaMasCercana$ con la posición de la caja más cercana a la puerta del contenedor contando el largo de la caja, el cuál daría el punto más cercano a la puerta del contenedor. En la línea 3: se inicializa una variable $PosicionMaxima$ con la posición máxima que un operador puede alcanzar con sus brazos, se calcula usando el punto más cercano a la puerta del contenedor menos la distancia establecida que los brazos de un operador puede alcanzar. En la línea 4: se inicializa una variable $i$ con la longitud de la lista de subespacios menos uno, esto para iterar siempre desde el último ya que la lista podría ser modificada durante la ejecución del bucle. En la línea 5: Se inicia un ciclo while que recorre la lista de subespacios desde el último hasta el primero. En la línea 6: Se verifica si el subespacio actual es profundo parcialmente. En la línea 7: Si el subespacio es profundo parcialmente, se recorta el subespacio para eliminar la parte profunda y se mantiene la parte más frontal accesible. En la línea 8: Se verifica si el subespacio actual es profundo totalmente. En la línea 9: Si el subespacio es profundo totalmente, se elimina el subespacio completamente de la lista. En la línea 10: Se decrementa el valor de $i$ en uno. En la línea 12: Se retorna la lista de subespacios actualizada.

\subsubsection{Algoritmo de llenado manual adaptado}

El Algoritmo \ref{alg:dblf_adaptado} muestra el procedimiento de llenado manual de paquetes en un contenedor considerando que los paquetes se reciben por tipos además usando las estrategias de unión de subespacios, eliminación de subespacios inaccesibles y eliminación de subespacios profundos.

\begin{algorithm}[H]
    \caption{Algoritmo de llenado manual de paquetes en un contenedor adaptado}
    \label{alg:dblf_adaptado}
    \begin{algorithmic}[1]
        \State \textbf{Parámetros:} $Tipos \gets \text{lista de tipos de paquetes}$
        \State \textbf{Inicialización:} $dblf \gets \text{lista inicializada con el espacio total del contenedor}$
        \State $Contenedor \gets \text{lista vacía para almacenar los paquetes colocados}$
        \For{$tipo \in Tipos$}
        \For{$i \gets 1 \text{ to } tipo.cantidad$}
        \State $SubespacioOptimo \gets \text{buscar el subespacio más adecuado en } dblf$
        \If{$SubespacioOptimo \neq \text{null}$}
        \State $Contenedor.\text{add}( \text{colocar}(tipo, SubespacioOptimo) )$
        \State $NuevosSubespacios \gets \text{dividir}(SubespacioOptimo, tipo)$
        \State $dblf.\text{remove}(SubespacioOptimo)$
        \State $dblf.\text{extend}(NuevosSubespacios)$
        \Else
        \State \textbf{print} $\text{"No se encontró espacio para el paquete."}$
        \EndIf
        \EndFor
        \State $dblf \gets \text{unirSubespacios}(dblf)$
        \State $dblf \gets \text{eliminarSubespaciosInaccesibles}(dblf)$
        \State $dblf \gets \text{eliminarSubespaciosProfundos}(dblf)$
        \EndFor
        \State \Return $Contenedor$
    \end{algorithmic}
\end{algorithm}

En el Algoritmo \ref{alg:dblf_adaptado}, en la línea 1: se recibe una lista llamada $Tipos$ que contiene los tipos de paquetes cuya información incluye el tamaño, rotación y cantidad de paquetes. En la línea 2: Se inicializa una lista llamada $dblf$, que representa los subespacios libres en el $Contenedor$. Inicialmente, esta lista contiene un único subespacio que es el contenedor entero. En la línea 3: Se crea una lista vacía llamada $Contenedor$ donde se almacenarán la posición y tamaños de los paquetes que se vayan colocando. Para la parte del proceso de llenado, en la línea 4: El ciclo for recorre cada tipo de paquete en la lista de tipos. En la línea 5: Se inicia un ciclo for que recorre la cantidad de paquetes por tipo. En la línea 6: Se busca en $dblf$ el primer subespacio disponible que sea suficientemente grande para el paquete. La búsqueda tiene en cuenta que el subespacio debe ser el más profundo, más bajo y más a la izquierda posible donde el paquete pueda caber. En la línea 7: Si tiene una condicional por si se encuentra o no un subespacio adecuado. De continuar con el procedimiento En la línea 8: La función $colocar$ ubica el $tipo$ en la posición más profunda, más baja y más a la izquierda del $SubespacioOptimo$ y devuelve la posición del paquete en el $Contenedor$, la función $add$ agrega el valor devuelto a la lista $Contenedor$. En la línea 9: El subespacio original $SubespacioOptimo$ donde se colocó el paquete se divide hasta en tres nuevos subespacios menores usando la función $dividir$. En la línea 10: se elimina el subespacio original $SubespacioOptimo$ de $dblf$ y en la línea 11: se agregan los nuevos subespacios a la lista $dblf$. En la línea 16: Se unen los subespacios similares en $dblf$ usando la función $unirSubespacios$. En la línea 17: Se eliminan los subespacios inaccesibles en $dblf$ usando la función $eliminarSubespaciosInaccesibles$. En la línea 18: Se eliminan los subespacios profundos en $dblf$ usando la función $eliminarSubespaciosProfundos$. En la línea 20: Se retorna la lista $Contenedor$ con los paquetes colocados.

\subsubsection{Mejora adicional al algoritmo de llenado}

Debido a la naturaleza altamente aleatoria propias de un algoritmo genético, es posible que se generen soluciones que se encuentren muy próximas de ser muy buenas pero que no evaluaron los espacios locales de manera adecuada, por lo que se propone un ajuste al algoritmo de llenado manual para que pueda aumentar la cantidad de cajas cuando sea posible de tal modo que se pueda aprovechar al máximo el espacio disponible.


\begin{figure}[H]
    \centering
    \includesvg[width=0.5\textwidth]{Figures/llenado_adicional.svg}
    \caption{Ejemplo de llenado adicional de un paquete tipo T1 donde ya se ha llenado dos tipos T1 (7 Cajas) y T2 (2 Cajas).}
    \label{fig:llenado_adicional}
\end{figure}

Por ejemplo, en la Figura \ref{fig:llenado_adicional} se ilustra un caso donde se ha completado el llenado de un tipo T1 específico con 7 paquetes y un tipo T2 con 2 paquetes, pero aún queda un espacio no usado donde podría ser aprovechado para añadir un octavo paquete del mismo tipo T1, siempre y cuando aún dispongamos de paquetes adicionales de ese tipo.

Esta situación presenta dos posibles mejoras para la gestión de paquetes. La primera consiste en añadir un paquete justo después de completar la carga de paquetes del mismo tipo. Esta opción podría optimizar el uso del espacio disponible de forma más eficiente, aunque existe el riesgo de que pueda deteriorar la calidad de la solución, ya que podría inferir en la colocación de los siguientes tipos de cajas. La segunda mejora propuesta es añadir el paquete una vez que se hayan llenado completamente todos los paquetes de todos los tipos. Si bien esta estrategia asegura que la calidad de la solución no se vea comprometida, podría no siempre haber muchos espacios libres que puedan ser aprovechados.

La primera mejora es llamada \textit{llenado adicional inmediato} y denominada M1, y la segunda mejora es llamada \textit{llenado adicional al final} y denominada  M2. Ambas mejoras solo se pueden aplicar en circunstancias específicas durante la ejecución del algoritmo genético y su rendimiento será evaluado en la sección de experimentos.

A continuación se resume el algoritmo de llenado manual adaptado con las mejoras M1 en el Algoritmo \ref{alg:dblf_adaptado_mejoras_m1}.

\begin{algorithm}[H]
    \caption{Algoritmo de llenado manual de paquetes en un contenedor adaptado con la mejora M1}
    \label{alg:dblf_adaptado_mejoras_m1}
    \begin{algorithmic}[1]
        \State \textbf{Parámetros:} $Tipos \gets \text{lista de tipos de paquetes}$
        \State \textbf{Inicialización:} $dblf \gets \text{lista inicializada con el espacio total del contenedor}$
        \State $Contenedor \gets \text{lista vacía para almacenar los paquetes colocados}$
        \For{$tipo \in Tipos$}
        \For{$i \gets 1 \text{ to } tipo.cantidad$}
        \State \text{...} \Comment{Mismo procedimiento que en el Algoritmo \ref{alg:dblf_adaptado}}
        \If{$i = tipo.cantidad$}
        \State $dblfSuperior \gets \text{filtrar solo subespacios superiores en } dblf$
        \State $SubespacioLibre \gets \text{buscar el subespacio más adecuado en } dblfSuperior$
        \If{$SubespacioLibre \neq \text{null}$}
        \State $tipo.cantidad \gets tipo.cantidad + 1$
        \EndIf
        \EndIf
        \EndFor
        \State \text{...} \Comment{Mismo procedimiento que en el Algoritmo \ref{alg:dblf_adaptado}}
        \EndFor
        \State \Return $Contenedor$
    \end{algorithmic}
\end{algorithm}

El Algoritmo \ref{alg:dblf_adaptado_mejoras_m1} es similar al Algoritmo \ref{alg:dblf_adaptado} con la diferencia de que se añade un paquete adicional del mismo tipo justo después de completar la carga de paquetes del mismo tipo. En la línea 7: Se verifica si el paquete actual es el último paquete del tipo, si es así, en la línea 8: se filtran solo los subespacios superiores en $dblf$ y en la línea 9: se busca el subespacio más adecuado en $dblfSuperior$. En la línea 10: Si se encuentra un subespacio adecuado, en la línea 11: se incrementa la cantidad de paquetes del tipo en uno, esto para que el bucle no termina hasta que se haya colocado el paquete adicional. En las siguientes líneas se realiza el mismo procedimiento que en el Algoritmo \ref{alg:dblf_adaptado}. En la línea 17: Se retorna la lista $Contenedor$ con los paquetes colocados.

Para el caso de la mejora M2 se sigue un procedimiento distinto, ya que se añade un paquete adicional una vez que se han llenado completamente todos los paquetes de todos los tipos. A continuación se resume el algoritmo de llenado manual adaptado con la mejora M2 en el Algoritmo \ref{alg:dblf_adaptado_mejoras_m2}.

\begin{algorithm}[H]
    \caption{Algoritmo de llenado manual de paquetes en un contenedor adaptado con la mejora M2}
    \label{alg:dblf_adaptado_mejoras_m2}
    \begin{algorithmic}[1]
        \State \textbf{Parámetros:} $Tipos \gets \text{lista de tipos de paquetes}$
        \State \textbf{Inicialización:} $dblf \gets \text{lista inicializada con el espacio total del contenedor}$
        \State $Contenedor \gets \text{lista vacía para almacenar los paquetes colocados}$
        \State $EspaciosSobrantes \gets \text{lista vacía para almacenar los espacios sobrantes}$
        \For{$tipo \in Tipos$}
        \For{$i \gets 1 \text{ to } tipo.cantidad$}
        \State \text{...} \Comment{Mismo procedimiento que en el Algoritmo \ref{alg:dblf_adaptado}}
        \EndFor
        \If{$existeEspacioSobrante(dblf)$}
        \State $EspaciosSobrantes \gets \text{filtrar solo subespacios sobrantes en } dblf$
        \EndIf
        \EndFor
        \State \text{...}
        \For{$tipo \in Tipos$}
        \For{$i \gets tipo.cantidad \text{ to } tipo.cantidadMaxima$}
        \State $SubespacioLibre \gets \text{buscar el subespacio más adecuado en } EspaciosSobrantes$
        \If{$SubespacioLibre \neq \text{null}$}
        \State $Contenedor.\text{add}( \text{colocar}(tipo, SubespacioLibre) )$
        \State $tipo.cantidad \gets tipo.cantidad + 1$
        \EndIf
        \EndFor
        \EndFor
        \State \text{...} \Comment{Mismo procedimiento que en el Algoritmo \ref{alg:dblf_adaptado}}
        \State \Return $Contenedor$
    \end{algorithmic}
\end{algorithm}

El Algoritmo \ref{alg:dblf_adaptado_mejoras_m2} también es similar al Algoritmo \ref{alg:dblf_adaptado} con la diferencia de que se durante todo el procedimiento de llenado se van recopilando los espacios libres para que luego se añada un paquete adicional una vez que se han llenado completamente todos los paquetes de todos los tipos. En la línea 9: Se verifica si existe algún espacio sobrante en $dblf$, si es así, en la línea 10: se filtran solo los subespacios sobrantes en $dblf$ y se almacenan en $EspaciosSobrantes$. En las siguientes líneas se realiza el mismo procedimiento que en el Algoritmo \ref{alg:dblf_adaptado}. En la línea 14: Se recorre nuevamente la lista de tipos de paquetes y en la línea 15: se recorre la cantidad de paquetes que faltan por añadir. En la línea 16: Se busca el subespacio más adecuado en $EspaciosSobrantes$. En la línea 17: Si se encuentra un subespacio adecuado, en la línea 18: se añade el paquete al contenedor y en la línea 19: se actualiza la cantidad de paquetes del tipo. En las siguientes líneas se realiza el mismo procedimiento que en el Algoritmo \ref{alg:dblf_adaptado}. En la línea 24: Se retorna la lista $Contenedor$ con los paquetes colocados.

Como se ha podido observar en los algoritmos presentados, si bien ambos tipos de mejoras tienen la misma finalidad de añadir paquetes adicionales al contenedor, cada una tiene sus propias ventajas y desventajas, por lo que se propone evaluar el rendimiento de cada una de ellas en la sección de experimentos.


\subsection{Población inicial}

Para generar la población inicial se propone un mecanismo simple de generación de soluciones aleatorias. Dado un conjunto de tipos de paquetes $T = \{1,2, \ldots, n\}$, donde cada tipo de paquete $t_i \in T$ tiene un mínimo y un máximo de paquetes a insertar en el contenedor $t_i \in [t_i^{min},t_i^{max}]$, se generan soluciones aleatorias de la siguiente manera:

\begin{enumerate}
    \item Se selecciona aleatoriamente un tipo de paquete $t_i \in T$.
    \item Se selecciona aleatoriamente un tipo de rotación $r_i \in R, R \in \{0,1\}$.
    \item Se selecciona aleatoriamente una cantidad de paquetes $q_i \in [t_i^{min},t_i^{max}]$.
    \item Se repiten los pasos 1 al 3 hasta que se hayan seleccionado todos los tipos de paquetes.
    \item Se repiten los pasos 1 al 4 hasta que se hayan generado $N$ soluciones.
\end{enumerate}

El algoritmo de generación de la población inicial se muestra en el Algoritmo~\ref{alg:generacionPoblacionInicial}. En este algoritmo, $T$ es el conjunto de tipos de paquetes, $R$ es el conjunto de rotaciones, $N$ es el tamaño de la población, $t_i^{min}$ y $t_i^{max}$ son el mínimo y el máximo de paquetes de cada tipo, respectivamente, y $P$ es la población inicial.

\begin{algorithm}[H]
    \caption{Generación de la población inicial}\label{alg:generacionPoblacionInicial}
    \begin{algorithmic}[1]
        \Require $T, R, N$
        \Ensure $P$
        \State $P \leftarrow \emptyset$
        \For{$i = 1$ to $N$}
        \State $S \leftarrow \emptyset$
        \For{each $t_i \in T$}
        \State $r \leftarrow$ rotación aleatoria de $R$
        \State $q \leftarrow$ cantidad aleatoria de paquetes entre $t_i^{\min}$ y $t_i^{\max}$
        \State $S \leftarrow S \cup \{(t_i, r, q)\}$
        \EndFor
        \State $P \leftarrow P \cup \{S\}$
        \EndFor
        \State \Return $P$
    \end{algorithmic}
\end{algorithm}

En el Algoritmo~\ref{alg:generacionPoblacionInicial}, en la línea 1: se inicializa una lista vacía $P$ que contendrá la población inicial. En el ciclo for de la línea 2: se itera para generar $N$ soluciones. En la línea 3: se inicializa una lista vacía $S$ que representa una solución. En el ciclo for de la línea 4: se itera para seleccionar aleatoriamente un tipo de paquete del conjunto de tipos $T$. En las línea 5: se selecciona aleatoriamente una rotación del conjunto de rotaciones $R$. En la línea 6: se selecciona aleatoriamente una cantidad de paquetes de acuerdo al mínimo y máximo de paquetes de cada tipo. En la línea 7: se añade el tipo de paquete, la rotación y la cantidad de paquetes a la solución $S$. En la línea 9: se añade la solución a la población. En la línea 11: se retorna la población generada.

De esta manera, las soluciones aleatorias generadas respetan las restricciones específicas del problema. Esto asegura que la cantidad de cada tipo de paquete insertado en el contenedor cumple con los rangos establecidos, manteniéndose entre el mínimo y el máximo definidos. Adicionalmente, se establece que estas cantidades sean generadas como números enteros, manteniendo la integridad de las soluciones conforme a las necesidades del problema.

\subsection{Selección}

Para seleccionar las soluciones que se utilizarán en cada generación del algoritmo evolutivo, se propone un mecanismo de selección basado en el método de torneo usando un tamaño de torneo de 2, también conocido como torneo binario. Anand y otros [3] lo describen como uno de los más eficientes métodos de selección para algoritmos evolutivos. Para usar el método de torneo binario, se seleccionan aleatoriamente dos soluciones de la población y se selecciona la mejor solución de las dos. Este proceso se lleva a cabo junto con el operador de cruce para lo cual cada padre se selecciona mediante un torneo binario.

En el Algoritmo~\ref{alg:seleccionPadres}, $P$ es la población, $N$ es el tamaño de la población, $P1$ y $P2$ son los padres seleccionados.

\begin{algorithm}[H]
    \caption{Selección de padres}\label{alg:seleccionPadres}
    \begin{algorithmic}[1]
        \Require $P, N$
        \Ensure $P1, P2$
        \State $P1 \leftarrow \emptyset$
        \State $P2 \leftarrow \emptyset$
        \For{$i = 1$ to $N$}
        \State $S1, S2 \leftarrow$ soluciones aleatorias de $P$
        \If{$S1$ > $P1$}
        \State $P1 \leftarrow P1 \cup S1$
        \Else
        \State $P1 \leftarrow P1 \cup S2$
        \EndIf
        \State $S3, S4 \leftarrow$ soluciones aleatorias de $P$
        \If{$S3$ > $P2$}
        \State $P2 \leftarrow P2 \cup S3$
        \Else
        \State $P2 \leftarrow P2 \cup S4$
        \EndIf
        \EndFor
        \State \Return $P1, P2$
    \end{algorithmic}
\end{algorithm}

En el Algoritmo~\ref{alg:seleccionPadres}, en la línea 1 y 2: se inicializan dos listas vacías $P1$ y $P2$ que contendrán los padres seleccionados. En el ciclo for de la línea 3: se itera para todo el tamaño de la población $N$. En las línea 4: se seleccionan aleatoriamente dos soluciones de la población $P$. En las líneas de la 5 a la 9: se selecciona la mejor solución de las dos y se añade a la lista $P1$. En las líneas de la 10 a la 15: se vuelve a repetir el proceso para seleccionar el segundo padre y se añade a la lista $P2$. En la línea 17: se retornan los padres seleccionados.

De acuerdo a lo anterior, se generan dos listas de padres que se utilizarán en el operador de cruce para generar una nueva población. Este método de selección procura que siempre se tienda a seleccionar soluciones mejores aunque tampoco se descartan soluciones peores, lo que permite mantener la diversidad en la población.

\subsection{Cruce}

Como se vió en la selección de padres, se generaron dos listas $P1$ y $P2$ que se utilizarán en el operador de cruce para generar una nueva población. Para el operador de cruce se propone un mecanismo de cruce basado en el cruce de un punto. Según \textcite{Umbarkar2015}, para este tipo de operador, se selecciona un punto aleatorio en el vector solución y se intercambian las partes de las dos soluciones que están a la izquierda y a la derecha del punto. Este operador de cruce es simple y fácil de implementar, y se ha demostrado que es eficiente para resolver problemas de optimización combinatoria.

Es importante destacar que el operador de cruce se aplica a una fracción específica de la población, determinada por una tasa de cruce, $P_{CROSS}$. Esta tasa representa la probabilidad de que dos soluciones seleccionadas sean cruzadas. La implementación de este mecanismo promueve la diversidad dentro de la población y fomenta la generación de nuevas soluciones potencialmente superiores a las existentes.

En el Algoritmo~\ref{alg:crucePadresGenerico}, $P1$ y $P2$ son los padres seleccionados, $C1$ y $C2$ son los hijos generados, $N$ es el tamaño de la población y $T$ es el conjunto de tipos de paquetes.

\begin{algorithm}[H]
    \caption{Cruce de padres genérico}\label{alg:crucePadresGenerico}
    \begin{algorithmic}[1]
        \Require $P1, P2, N, T$
        \Ensure $C1, C2$

        \State $C1 \leftarrow \emptyset$
        \State $C2 \leftarrow \emptyset$
        \State $p \leftarrow$ punto aleatorio en la solución
        \For{$i = 1$ to $N$}
        \If{$i \leq p$}
        \State $C1 \leftarrow C1 \cup P1[i]$
        \State $C2 \leftarrow C2 \cup P2[i]$
        \Else
        \State $C1 \leftarrow C1 \cup P2[i]$
        \State $C2 \leftarrow C2 \cup P1[i]$
        \EndIf
        \EndFor
        \State \Return $C1, C2$
    \end{algorithmic}
\end{algorithm}

Por lo tanto, al intentar aplicar el algoritmo sobre la Codificación de Soluciones propuesta en la sección \ref{sec:codificacion}, se puede representar en la Figura \ref{fig:cruce_simple} el cruce de dos padres $P1$ y $P2$.

\begin{figure}[H]
    \centering
    \includesvg[width=0.5\textwidth]{Figures/cruce_simple.svg}
    \caption{Cruce de dos padres $P1$ y $P2$}
    \label{fig:cruce_simple}
\end{figure}

Como puede verse en la Figura \ref{fig:cruce_simple}, se selecciona un punto aleatorio en la solución (en este caso se encuentra en la quinta posición) y si se intercambian las partes de las dos soluciones que están a la izquierda y a la derecha del punto, las soluciones hijas resultantes tendrían una alta probabilidad de ser no factibles ya que se estarían repitiendo tipos de paquetes en el contenedor.

Si bien este algoritmo de cruce es ampliamente aplicable a diversos tipos de problemas, es particularmente adaptable al problema de llenado de contenedores, teniendo en cuenta la codificación propuesta en la sección \ref{sec:codificacion}. Se propone, por tanto, un mecanismo de cruce diseñado para asegurar la factibilidad de las soluciones generadas. Este método consiste en utilizar la primera partición de la solución de un progenitor y completarla con los tipos de paquetes aún no seleccionados de la misma partición. De esta manera, se asegura que cada solución generada, o hijo, contenga todos los tipos de paquetes, garantizando su viabilidad.

En la Figura \ref{fig:cruce_propuesto} se muestra el cruce de dos padres $P1$ y $P2$ utilizando el algoritmo de cruce propuesto.

\begin{figure}[H]
    \centering
    \includesvg[width=0.75\textwidth]{Figures/cruce_propuesto.svg}
    \caption{Cruce de dos padres $P1$ y $P2$ utilizando el algoritmo de cruce propuesto}
    \label{fig:cruce_propuesto}
\end{figure}

Como se ilustra en la Figura \ref{fig:cruce_propuesto}, el proceso de cruce se detalla para los padres P2 y P1. A P2 le faltan los tipos de paquetes T3, T5 y T7; tras buscar en P1, se agregan en el orden encontrado: T5, T7, T3. En el caso de P1, le faltan los tipos T1, T6 y T3, que al buscarse en P2 se encuentran y se añaden en el orden de T6, T1 y T3. Este método asegura que las soluciones generadas, C1 y C2, sean factibles al completar los tipos de paquetes faltantes en cada padre, manteniendo así la viabilidad de las soluciones.

Por lo tanto, el algoritmo propuesto, adaptado a la codificación, para el cruce de padres se muestra en el Algoritmo~\ref{alg:crucePadresPropuesto}.

\begin{algorithm}[H]
    \caption{Cruce de padres propuesto}\label{alg:crucePadresPropuesto}
    \begin{algorithmic}[1]
        \Require $P1, P2, N, T$
        \Ensure $C1, C2$

        \State $C1 \leftarrow \emptyset$
        \State $C2 \leftarrow \emptyset$
        \State $p \leftarrow$ punto aleatorio en la solución
        \For{$i = 1$ to $N$}
        \If{$i \leq p$}
        \State $C1 \leftarrow C1 \cup P1[i]$
        \State $C2 \leftarrow C2 \cup P2[i]$
        \Else
        \For{each $t_i \in T$}
        \If{$C1$ no contiene $P2[i]$}
        \State $C1 \leftarrow C1 \cup P2[i]$
        \EndIf
        \If{$C2$ no contiene $P1[i]$}
        \State $C2 \leftarrow C2 \cup P1[i]$
        \EndIf
        \EndFor
        \EndIf
        \EndFor
        \State \Return $C1, C2$
    \end{algorithmic}
\end{algorithm}

En el Algoritmo~\ref{alg:crucePadresPropuesto}, en las líneas 1 y 2 se inicializan dos listas vacías $C1$ y $C2$ que contendrán los hijos generados. En la línea 3 se selecciona un punto aleatorio $p$ en la solución de tamaño $N$. En el ciclo for de la línea 4 se itera para todo el tamaño de la población $N$. En las líneas de la 5 a la 8 se conservan las primeras $p$ posiciones de los padres $P1$ y $P2$ respectivamente. En la línea 9 se inicia un ciclo para cada tipo de paquete $t_i \in T$. En las líneas de la 10 a la 12 se verifica si el hijo $C1$ no contiene el tipo de paquete $P2[i]$ y si es así se añade a $C1$. En las líneas de la 13 a la 15 se verifica si el hijo $C2$ no contiene el tipo de paquete $P1[i]$ y si es así se añade a $C2$. En la línea 19 se retorna los dos hijos generados $C1$ y $C2$.

Consecuentemente, se asegura que las soluciones generadas no solo sean factibles y abarquen todos los tipos de paquetes, sino que también difieran de las soluciones padres, contribuyendo así a la preservación de la diversidad dentro de la población.

\subsection{Mutación}

Según \textcite{Dockhorn2022}, la mutación consiste en aplicar pequeños cambios a las soluciones candidatas para tratar de explorar nuevas regiones locales del espacio de búsqueda. Para el presente problema, ya que codificación propuesta consta de tres listas, se propone también tres operadores de mutación, uno para cada lista. El primer tipo de mutación intercambia dos tipos de paquetes en la secuencia de llenado junto a su rotación y cantidad específica, el segundo tipo de mutación solo intercambia la rotación de un tipo de paquete y el tercer tipo de mutación cambia la cantidad de paquetes de un tipo de paquete.

Cabe mencionar que el operador de mutación se aplica a una proporción muy pequeña de la población, dependiendo de una tasa de mutación $P_{MUT}$, que se define como la probabilidad de que una solución seleccionada mute y generé una nueva solución cercana a la inicial.

En la Figura \ref{fig:mutacion_tipo} se muestra un ejemplo de mutación de un tipo de paquete en la secuencia de llenado, se elige dos tipos de paquetes aleatorios y se intercambian.

\begin{figure}[H]
    \centering
    \includesvg[width=0.5\textwidth]{Figures/mutacion_tipos.svg}
    \caption{Mutación de un tipo de paquete en la secuencia de llenado}
    \label{fig:mutacion_tipo}
\end{figure}

En la Figura \ref{fig:mutacion_rotacion} se muestra un ejemplo de mutación de la rotación de un tipo de paquete en la secuencia de llenado, se elige un tipo de paquete aleatorio y se cambia la rotación del estado 0 (no rotado) hacia el estado 1 (rotado).

\begin{figure}[H]
    \centering
    \includesvg[width=0.5\textwidth]{Figures/mutacion_rotacion.svg}
    \caption{Mutación de la rotación de un tipo de paquete en la secuencia de llenado}
    \label{fig:mutacion_rotacion}
\end{figure}

En la Figura \ref{fig:mutacion_cantidad} se muestra un ejemplo de mutación de la cantidad de paquetes de un tipo de paquete en la secuencia de llenado, se elige un tipo de paquete aleatorio y se cambia la cantidad de paquetes.

\begin{figure}[H]
    \centering
    \includesvg[width=0.5\textwidth]{Figures/mutacion_cantidad.svg}
    \caption{Mutación de la cantidad de paquetes de un tipo de paquete en la secuencia de llenado}
    \label{fig:mutacion_cantidad}
\end{figure}

Aunque estos tres tipos de mutación no se pueden aplicar a la vez, se puede seleccionar el tipo de mutación aleatoriamente y aplicarla a la solución seleccionada. Por lo tanto, el algoritmo de mutación se muestra en el Algoritmo~\ref{alg:mutacion}. En este algoritmo, $S$ es la solución a mutar, $T$ es el conjunto de tipos de paquetes, $R$ es el conjunto de rotaciones, $t_i^{\min}$ y $t_i^{\max}$ son el mínimo y el máximo de paquetes de cada tipo, respectivamente, y $S'$ es la solución mutada.

\begin{algorithm}[H]
    \caption{Mutación de soluciones}\label{alg:mutacion}
    \begin{algorithmic}[1]
        \Require $S, T, R, t_i^{\min}, t_i^{\max}$
        \Ensure $S'$
        \State $S' \leftarrow S$
        \State $m \leftarrow$ número aleatorio entre 1 y 3
        \If{$m = 1$}
        \State $i, j \leftarrow$ dos números aleatorios entre 1 y $|T|$
        \State $S'[i], S'[j] \leftarrow S[j], S[i]$
        \ElsIf{$m = 2$}
        \State $i \leftarrow$ número aleatorio entre 1 y $|T|$
        \State $S'[i] \leftarrow$ intercambio de rotación de $S[i]$
        \ElsIf{$m = 3$}
        \State $i \leftarrow$ número aleatorio entre 1 y $|T|$
        \State $q \leftarrow$ variar la cantidad paquetes de $S[i]$
        \State $S'[i] \leftarrow q$
        \EndIf
        \State \Return $S'$
    \end{algorithmic}
\end{algorithm}

En el Algoritmo~\ref{alg:mutacion}, en la línea 1 se inicializa una solución mutada $S'$ con la solución original $S$. En la línea 2 se selecciona aleatoriamente un número $m$ entre 1 y 3 que representa el tipo de mutación a aplicar. En la línea 3 se verifica si el número aleatorio es igual a 1, si es así, en las líneas 4 y 5 se seleccionan dos números aleatorios $i$ y $j$ entre 1 y el tamaño de $T$ y se intercambian los tipos de paquetes en las posiciones $i$ y $j$ de la solución $S'$. En la línea 6 se verifica si el número aleatorio es igual a 2, si es así, en la línea 7 se selecciona un número aleatorio $i$ entre 1 y el tamaño de $T$ y en la linea 8 se intercambia la rotación del tipo de paquete en la posición $i$ de la solución $S'$. En la línea 9 se verifica si el número aleatorio es igual a 3, si es así, en las líneas 10 se selecciona un número aleatorio $i$ entre 1 y el tamaño de $T$. En la línea 11 se varía la cantidad de paquetes del tipo de paquete en la posición $i$ de la solución $S'$, esto implica que la cantidad puede incrementar o disminuir. En la línea 14 se retorna la solución mutada $S'$.

\subsection{Elitismo}

Según \textcite{Hasni2013}, el principio del elitismo consiste en mantener las mejores soluciones de una generación a la siguiente, lo que permite garantizar que siempre se mantenga la mejor solución encontrada hasta el momento, ya que los operadores de cruce y mutación pueden generar soluciones las cuales no sean mejores que las soluciones actuales, en dicho caso se reemplazan el mejor individuo de la generación anterior por el peor individuo de la generación actual.

Por lo tanto, se propone un mecanismo de elitismo que garantice que siempre se mantenga la mejor solución encontrada hasta el momento. Para ello, se selecciona la mejor solución de la población actual y se compara con la mejor solución élite encontrada hasta el momento. Si la mejor solución de la población actual es mejor que la mejor solución élite encontrada hasta el momento, se sustituye la mejor solución élite por la mejor solución de la población actual, de lo contrario, la solución élite reemplaza a la peor solución de la población actual.

El algoritmo de elitismo se muestra en el Algoritmo~\ref{alg:elitismo}. En este algoritmo, $P$ es la población actual, $S$ es la mejor solución encontrada hasta el momento y $S'$ es la mejor solución de la población actual.

\begin{algorithm}[H]
    \caption{Elitismo}\label{alg:elitismo}
    \begin{algorithmic}[1]
        \Require $P, S$
        \Ensure $S'$
        \State $S' \leftarrow$ mejor solución de $P$
        \If{$S'$ > $S$}
        \State $S \leftarrow S'$
        \Else
        \State $P \leftarrow$ reemplazo de la peor solución de $P$ por $S$
        \EndIf
        \State \Return $S$
    \end{algorithmic}

\end{algorithm}

En el Algoritmo~\ref{alg:elitismo}, en la línea 1 se selecciona la mejor solución de la población actual $P$ y se almacena en $S'$. En la línea 2 se usa la función de evaluación para verificar si la mejor solución de la población actual $S'$ es mejor que la mejor solución encontrada hasta el momento $S$, si es así, en la línea 3 se reemplaza la mejor solución encontrada hasta el momento $S$ por la mejor solución de la población actual $S'$. Si la verificación de la linea 2 es falsa, en la línea 5 se reemplaza la peor solución de la población actual $P$ por la mejor solución encontrada hasta el momento $S$. En la línea 6 se retorna la mejor solución  $S$ que se mantendrá en las generaciones futuras.

Como resultado, se asegura la preservación de la mejor solución identificada hasta el momento, evitando su pérdida en futuras generaciones.

\subsection{Algoritmo genético}

Con todos los operadores definidos, se puede definir el algoritmo genético completo. En el Algoritmo~\ref{alg:algoritmoGenetico}, $T$ es el conjunto de tipos de paquetes, $R$ es el conjunto de rotaciones, $N$ es el tamaño de la población, $P_{CROSS}$ es la tasa de cruce, $P_{MUT}$ es la tasa de mutación y $G$ es la condiciones de parada que podría ser una cantidad máxima de tiempo, una cantidad máxima de generaciones en que la mejor solución no ha mejorado o simplemente una cantidad máxima de generaciones en total.

\begin{algorithm}[H]
    \caption{Algoritmo genético}\label{alg:algoritmoGenetico}
    \begin{algorithmic}[1]
        \Require $T, R, N, P_{CROSS}, P_{MUT}, G$
        \Ensure $S$
        \State $P \leftarrow$ generación de la población inicial
        \State $S \leftarrow$ mejor solución de $P$
        \While {(no se cumpla la condición de parada $G$)}
        \State $P1,P2 \leftarrow$ Realizar selección en $P$
        \State $P \leftarrow$ Realizar cruzamiento en $P1$ y $P2$ con tasa $P_{CROSS}$
        \State $P \leftarrow$ Aplicar mutación a $P$ con tasa $P_{MUT}$
        \State $S \leftarrow$ Realizar elitismo en $P$ con $S$
        \EndWhile
        \State \Return $S$
    \end{algorithmic}
\end{algorithm}

En el Algoritmo~\ref{alg:algoritmoGenetico}, en la línea 1 se genera la población inicial $P$. En la línea 2 se usa la función de evaluación para seleccionar la mejor solución de la población inicial $P$ y se almacena en $S$. En el ciclo while de las líneas 3 a 8 se itera mientras no se cumpla la condición de parada $G$. En las línea 4 se seleccionan los padres $P1$ y $P2$ de la futura generación y en la linea 5 se realiza el cruce de los padres seleccionados con una tasa de cruce $P_{CROSS}$. En la línea 6 se aplica la mutación a la población $P$ (que ya paso por el operador de cruce) con una tasa de mutación $P_{MUT}$. En la línea 7 se realiza el elitismo en la población $P$ (que ya paso por los operadores de cruce y mutación) con la mejor solución élite $S$. En la línea 9 se retorna la mejor solución $S$ encontrada.

Al finalizar el algoritmo, se obtiene la mejor solución encontrada que representa la mejor forma de llenar el contenedor con los paquetes disponibles de modo que se maximice el valor total de los paquetes colocados y que se cumplan las restricciones prácticas del problema.